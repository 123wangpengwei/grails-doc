Grails 3.3 includes several changes to dependencies and Event publishing that may require changes to your application if you are upgrading from Grails 3.2.x.

TIP: For information on upgrading from versions of Grails prior to Grails 3.2.x, see the http://docs.grails.org/3.2.x/guide/upgrading.html[Grails 3.2.x documentation on upgrading]

=== GORM 6.1 Upgrade

GORM 6.1 http://gorm.grails.org/latest/hibernate/manual/index.html#upgradeNotes[includes changes] that may require you to change your application.

==== GORM Async Now Optional

Notably `grails-datastore-gorm-async` is now optional and if you use the `task` method of GORM you will need to manually implement the `AsyncEntity` trait.

==== Domain Autowiring Disabled

Domain class autowiring is disabled by default due to its impact on performance. You can re-enable autowiring using the `grails.gorm.autowire` setting in `application.yml`.

==== Flush Mode now COMMIT by Default

The default flush mode has been change to `COMMIT` due to the impact the previous flush mode `AUTO` has on read performance. You can switch back to `AUTO` use the `hibernate.flush.mode` setting in `application.yml`

==== TransactionManager Chaining for Multiple Data Sources Disabled by Default

In previous versions of Grails for multiple data sources a best effort transaction chain was used to attempt to manage a transaction across all configured data sources.

As of Grails 3.3 this is disabled as it caused confusion since it isn't a true XA implementation and also impacts performance as for every transaction you have a transaction for each data source bound regardless if that is the actual requirement.

If your application depends on this feature you can re-enable it with the following configuration:

[source,yaml]
----
grails:
  transaction:
    chainedTransactionManagerPostProcessor:
      enabled: true
      blacklistPattern: '.*'
----

==== Tomcat JDBC

GORM 6.1 and above now supports multiple connection pool options, so the `tomcat-jdbc` dependency is now optional. If you are upgrading you may need to add it (or another pool implementation) to your `build.gradle`:

[source,groovy]
.build.gradle
----
runtime 'org.apache.tomcat:tomcat-jdbc'
----

=== Default Logger Name

In previous versions of Grails, if you did not specify a logger in the controller, service, etc, a `log` variable was injected for you. The naming convention of that logger was `grails.app.${artefactType}.package.class`. For example:

`grails.app.controllers.foo.bar.MyController`

To make the logger names more intuitive as well as to increase consistency between custom code, plugin dependencies, and third party libraries, the `grails.app.${artefactType}` convention was removed. The same class as above will now be referenced the same way as any standard class. The way the `log` variable gets injected was also changed to defer to the Slf4j transformation. That means it is no longer necessary to check `if (log.isDebugEnabled())`.

The downside of this change is that it isn't immediately simple to set up the same logging configuration for all controllers, for example. We think this can be solved with a package naming strategy that represents what your requirements are.

=== Dependency Alterations

In an effort to trim the size of the produced WAR file by Grails several dependencies are no longer resolved transtively including:

* `commons-lang`
* `gson`
* `aspectjweaver`
* `aspectjrt`
* `ehcache`

If you are upgrading and have referenced any of these dependencies in your application you may need to alter your build to reference them.

=== Spring Boot 1.5.x

Spring Boot 1.5.x removes a number of deprecated classes, notably all of the classes within the `org.springframework.boot.context.embedded` package.

If your application is referencing any of the classes within this package you will need to alter your imports to use `org.springframework.boot.web.servlet` instead.

=== Reactor 2.x Deprecated and Removed

Since Reactor 2.x is no longer being maintained and a new link:{asyncdocs}[EventBus] abstraction has been implemented, Reactor 2.x and all its dependencies have been removed.

A compatibility layer has been provided to allow classes compiled with the previous version that uses Reactor to run, however all plugins and application code should be re-compiled and direct references to Reactor 2.x should be removed.

=== Externalized Plugins

Several plugins and libraries have been separated from Grails core into standalone projects. The following table summarizes the previous artefact id, the new artefact id and the location of the new sources:

.Externalized Plugins
|===
|Previous Artefact ID |New Artefact ID |Sources

|`org.grails:grails-plugin-gsp`
|`org.grails.plugins:gsp`
|https://github.com/grails/grails-gsp

|`org.grails:grails-plugin-converters`
|`org.grails.plugins:converters`
|https://github.com/grails-plugins/grails-plugin-converters

|`org.grails:grails-plugin-async`
|`org.grails.plugins:async`
|https://github.com/grails/grails-async

|`org.grails:grails-plugin-events`
|`org.grails.plugins:events`
|https://github.com/grails/grails-events

|===

=== Grails Domain Class API Deprecated

The legacy classes that represent domain classes and their properties have been deprecated in favor of the mapping context API. The internal implementation of the methods in those classes now delegates to the mapping context. Due to that change, information about your domain classes is not available until the application context is available.

In previous versions of Grails it was possible to access link:api/grails/core/GrailsDomainClass.html[GrailsDomainClass] instances and inspect the link:api/grails/core/GrailsDomainClassProperty.html[GrailsDomainClassProperty] properties inside of the `doWithSpring` method in a plugin, for example.

If you have code that follows that example, an error will be thrown that looks like "The method ... cannot be accessed before GORM has initialized". The solution is to move any logic that executes before the context is available to somewhere else that executes after the context is available.

All code that uses the link:api/grails/core/GrailsDomainClass.html[GrailsDomainClass] or link:api/grails/core/GrailsDomainClassProperty.html[GrailsDomainClassProperty] classes should be re-written to use the mapping context api.

To get started, inject the `grailsDomainClassMappingContext` bean. See the api documentation for more information on the link:{grails.gorm}org/grails/datastore/mapping/model/MappingContext.html[MappingContext], link:{grails.gorm}org/grails/datastore/mapping/model/PersistentEntity.html[PersistentEntity] (GrailsDomainClass), and link:{grails.gorm}org/grails/datastore/mapping/model/PersistentProperty.html[PersistentProperty] (GrailsDomainClassProperty).

=== Task Groups

Several tasks have had their groups changed to better reflect their purpose. If you're having trouble finding a task, look through the different groups.

=== Legacy JSON Builder Option Removed

In a previous version of Grails, the JSON builder used by default for rendering JSON inline was changed. The previous behavior of using converters to build the JSON was able to be re-enabled by setting `grails.json.legacy.builder` to true. In Grails 3.3 that setting has been removed and it is no longer possible to use the legacy converter API to render JSON inline via the `render` method.

=== Datasource Plugin Revamp

As a result of major changes to the dataSources plugin, beans for the lazy and unproxied representation of a dataSource are no longer available.

Example:

* dataSourceUnproxied
* dataSourceLazy
